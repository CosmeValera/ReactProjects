Rundeck:

# Why Rundeck?
It supports SRE (Site Reliability Engineering), one of the main ideas of SRE is to reduce TOIL. Toil is repetitive and manual tasks that are necessary for the system but are time-consuming and do not provide long-term value.
For doing this, Rundeck promotes workload automation. For this it allows to execute or schedule jobs to be automated.
Rundeck is great for orchestrating procedures.

# How it works:
- Projects are workspaces inside your Rundeck.
- Jobs are the workflows that you define and execute.
- Steps are the individual actions that make up the workflow. For instance, you can execute commands, scripts or plugins.
- Nodes are the remotes endpoints against which a step executes. For instance, physical machines, virtual machines, containers, databases...

ðŸš€ Getting Started
# Create container to run Rundeck
docker run -d --name rundeck -p 4440:4440 -v data:/home/rundeck/server/data rundeck/rundeck:4.14.0
# Open browser
localhost:4440

#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$
#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$

# Difference Ansible and Rundeck #
Ansible:
- Ansible is a configuration management tool that focuses on automation.
- With Ansible, you define tasks or playbooks that describe the desired state of your infrastructure.
- You then execute these playbooks using the Ansible command-line interface (CLI) or by integrating Ansible into other tools or workflows.
- Ansible typically operates in a push model, where the control machine pushes configurations or commands to the target machines over SSH.
- It's commonly used for tasks such as software installation, configuration management, and application deployment.

Rundeck:
- Rundeck is an operations automation tool that provides a web-based interface for executing tasks and workflows.
- With Rundeck, you define jobs or workflows that consist of one or more steps (commands or scripts).
- Users can then trigger these jobs manually through the Rundeck web interface or via API calls.
- Rundeck can execute tasks on remote machines, similar to Ansible, but it also supports executing tasks on the Rundeck server itself.
- It's often used for tasks such as ad-hoc command execution, job scheduling, and workflow orchestration.

So, while both Ansible and Rundeck can be used for automation and executing tasks on remote machines, Ansible is more focused on configuration management and operates in a push model, while Rundeck provides a centralized platform for managing and executing operations tasks with a web-based interface.
# END: Difference Ansible and Rundeck #

#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$
#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$

Ansible:
- Focused in automation
- Yaml and Python based
- Agentless
- SSH
- PUSH model

YAML:
	Key Value Pair:
		Fruit: Apple
		Vegetable: Carrot
	
	Array/Lists:
		Fruits:
			- Orange
			- Apple
		
	Dictionary/Map:
		Banana:
			Calories: 106
			Fat: 0.4g
	
	Object:
		- Car: Toyota
		  Speed: 100
			
	---
	List of Dictionary:
		Fruits:
			- Banana:
			    Calories: 106
			    Fat: 0.4g
			- Grape:
				Calories: 106
				Fat: 0.4g
				
	Objects list:
		Tasks:
			- name: task1
			  firstStep: echo hola
			- name: task2
			  firstStep: echo adios
			
#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$
#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$#.@-$

Ansible Advanced:
Ansible works with multiple servers, for this it uses SSH.
The information about this servers is stored in the inventory file. Which by default is in 'etc/ansible/hosts'. It looks like this->
'
server1.company.com
server2.company.com

[mail]
server3.company.com
server4.company.com
'
You can also put an alias to the ansible connection, and it would look like this: 'web ansible_host=server1.company.com'
The inventory parameters are:
'
ansible_connection - ssh/winrm/localhost
ansible_port - 22/5986
ansible_user - root/administrator
ansible_ssh_pass - Password (in windows-> ansible_password)
'.
So one full line may look like this:'web ansible_host=server1.company.com ansible_connection=ssh ansible_user=root ansible_ssh_pass=P@#'
And an inventory file could look like this (ini):
'
# Sample Inventory File

# Web Servers
web_node1 ansible_host=web01.xyz.com ansible_connection=winrm ansible_user=administrator ansible_password=Win$Pass
web_node2 ansible_host=web02.xyz.com ansible_connection=winrm ansible_user=administrator ansible_password=Win$Pass
web_node3 ansible_host=web03.xyz.com ansible_connection=winrm ansible_user=administrator ansible_password=Win$Pass

# DB Servers
sql_db1 ansible_host=sql01.xyz.com ansible_connection=ssh ansible_user=root ansible_ssh_pass=Lin$Pass
sql_db2 ansible_host=sql02.xyz.com ansible_connection=ssh ansible_user=root ansible_ssh_pass=Lin$Pass

[db_nodes]
sql_db1
sql_db2

[web_nodes]
web_node1
web_node2
web_node3

[boston_nodes]
sql_db1
web_node1

[dallas_nodes]
sql_db2
web_node2
web_node3

[us_nodes:children]
boston_nodes
dallas_nodes
'

And an inventory file could look like this (YAML):
'
all:
	children:
		webservers:
			children:
				webserver_us:
					hosts:
						server1_us.com:
							ansible_host: 192.168.8.101
						server2_us.com:
							ansible_host: 192.168.8.102
				webserver_eu:
					hosts:
						server1_eu.com:
							ansible_host: 10.12.0.101
						server2_eu.com:
							ansible_host: 10.12.0.102
'

Ansible variables:
- Stores information that varies with each host
- Can be set in the inventory file, or in a variables file.
Playbook.yml:
'
-   name: Add DNS server to resolv.conf
	hosts: localhost
	vars:
		dns_server: 10.1.250.10
	tasks:
	  - lineinfile:
			path: /etc/resolv.conf
			line: 'nameserver {{ dns_server }}'
'
- variable types: String, Number, Boolean, List, Dictionary.
- Variable precedence: Playbook > Host > Group. 
These are just 3, the 22 precedence relations can be found in the docu: https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#understanding-variable-precedence

Registering Variables:
1.
' 
---
- name: Check /etc/hosts file
  hosts: all
  tasks:
  -	shell: cat /etc/hosts
	register: result
  - debug:
	var: result
'
In this example, with the keyword register, we store result, and then use this result in the debug module ot obtain more details about how it went.

2. 
'
$ ansible-playbook -i inventory playbook.yml -v
'
On the other hand, having the playbook normal, but making the script call with -v (verbose). Will also increase the amount of detail. But the detail won't be as specific as in using register. Options-> -v, -vv, -vvv.

Variable scoping:
1. Variables defined for a group of groups, a group, or a host, are considered to be host scoped.
2. Variables scroped in a play, ar play scoped. 
3. Global variables are globally scoped.

Magic variables:
Code A:
'
web1 ansible_host=172.20.1.100
web2 ansible_host=172.20.1.101 dns_server=10.5.5.4
web3 ansible_host=172.20.1.102
'
In code A. the variable for the dns_server is only available for host web2. However there is a way to be able to use the variables of other hosts. IN this case with this playbook, when instead of using '{{ dns_server }}', you use '{{ hostvars['web2'].dns_server }}', you will be able to access the variable of the host web2. Like in the following example->
'
---
- name: Print dns server
  hosts: all
  tasks:
  - debug:
	msg: '{{ hostvars['web2'].dns_server }}'
'.
In addition to 'hostvars', there are more magic variables like: groups, group_names, inventory_hostname...
https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_vars_facts.html#information-about-ansible-magic-variables
And also there are 2 options to write it, both mean the same:
1. '{{ hostvars['web2'].ansible_facts.processor }}'
2. '{{ hostvars['web2'][ansible_facts][processor] }}'

Ansible Facts:
